module;

#include <print>

export module base.colours;
export namespace base::text {
/// Mixin to simplify formatting strings with colours.
///
/// A formatting code starts with a per cent sign, and the text to
/// be formatted is enclosed in parentheses; the format it reset to
/// what it was before after the closing parenthesis.
///
/// Example: format("%b({} %1({}) {})", 1, 2, 3) outputs "1 2 3", with
/// the '1' and '3' formatted in bold, and the '2' in red and bold.
///
/// Formatting codes can also be combined, e.g. "%b1(...)" is bold and red.
///
/// Supported formatting codes:
/// - %b: bold.
/// - %1-%9: ANSI terminal colours (e.g. %4 becomes \033[34m).
/// - %r: reset everything. This must be specified before any other formatting codes.
/// - %u: curly underline; if the next character is a digit, it becomes the underline colour.
class ColourFormatter;

/// A string that contains formatting characters that still need
/// to be rendered.
template <typename StringTy>
class BasicUnrenderedString;
using UnrenderedString = BasicUnrenderedString<std::string>;

/// Render colours in a string.
[[nodiscard]] auto RenderColours(bool use_colours, std::string_view fmt) -> std::string;
} // namespace base::text

namespace base::text {
template <typename>
struct AnyUnrenderedStringImpl {
    static constexpr bool value = false;
};

template <typename Ty>
requires std::is_reference_v<Ty>
struct AnyUnrenderedStringImpl<Ty> {
    static constexpr bool value = AnyUnrenderedStringImpl<std::remove_reference_t<Ty>>::value;
};

template <typename Ty>
struct AnyUnrenderedStringImpl<const Ty> {
    static constexpr bool value = AnyUnrenderedStringImpl<Ty>::value;
};

template <typename StringTy>
struct AnyUnrenderedStringImpl<BasicUnrenderedString<StringTy>> {
    static constexpr bool value = true;
};

template <typename Ty>
concept AnyUnrenderedString = AnyUnrenderedStringImpl<Ty>::value;

template <typename Ty>
struct RenderedImpl {
    using type = Ty;
};

template <AnyUnrenderedString Ty>
struct RenderedImpl<Ty> {
    using type = std::string_view;
};

template <typename Ty>
using Rendered = typename RenderedImpl<Ty>::type;

template <typename Ty>
requires (not AnyUnrenderedString<Ty>)
decltype(auto) Extract(Ty&& arg) { return std::forward<Ty>(arg); }

auto Extract(AnyUnrenderedString auto&& arg) -> std::string_view {
    return std::string_view{arg.str};
}
} // namespace base::text

/// Mixin to simplify formatting strings with colours.
///
/// A formatting code starts with a per cent sign, and the text to
/// be formatted is enclosed in parentheses; the format it reset to
/// what it was before after the closing parenthesis.
///
/// Example: format("%b({} %1({}) {})", 1, 2, 3) outputs "1 2 3", with
/// the '1' and '3' formatted in bold, and the '2' in red and bold.
///
/// Formatting codes can also be combined, e.g. "%b1(...)" is bold and red.
///
/// Supported formatting codes:
/// - %b: bold.
/// - %1-%9: ANSI terminal colours (e.g. %4 becomes \033[34m).
/// - %r: reset everything. This must be specified before any other formatting codes.
/// - %u: curly underline; if the next character is a digit, it becomes the underline colour.
///
/// Note that the traditional escape character, i.e. '\033', can be used
/// to escape any character, e.g. '\033%' is a literal '%' sign. This is
/// also often required for literal closed parentheses, e.g. '%b(\033))'
/// produces a bold ')'.
class base::text::ColourFormatter {
public:
    template <typename... Args>
    auto format(
        this auto&& self,
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) -> std::string {
        return text::RenderColours(
            self.use_colour(),
            std::format(fmt, text::Extract(std::forward<Args>(args))...)
        );
    }

    template <typename... Args>
    void print(
        this auto&& self,
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) {
        std::print(stdout, "{}", self.format(fmt, std::forward<Args>(args)...));
    }

    template <typename... Args>
    void print(
        this auto&& self,
        FILE* f,
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) {
        std::print(f, "{}", self.format(fmt, std::forward<Args>(args)...));
    }

    template <typename... Args>
    void write(
        this auto&& self,
        std::string& out,
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) {
        out += self.format(fmt, std::forward<Args>(args)...);
    }

    template <typename OutputStream, typename... Args>
    requires requires (OutputStream& os, std::string s) { os << s; }
    void write(
        this auto&& self,
        OutputStream& os,
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) {
        os << self.format(fmt, std::forward<Args>(args)...);
    }
};

template <typename StringTy = std::string>
class base::text::BasicUnrenderedString {
    friend ColourFormatter;
    friend auto text::Extract(AnyUnrenderedString auto&& arg) -> std::string_view;
    StringTy str;

public:
    BasicUnrenderedString() = default;

    auto operator+=(char c) -> BasicUnrenderedString& {
        str += c;
        return *this;
    }

    auto operator+=(std::string_view s) -> BasicUnrenderedString& {
        str += s;
        return *this;
    }

    template <typename Ty>
    auto operator+=(const BasicUnrenderedString<Ty>& s) {
        str += s.str;
        return *this;
    }

    template <typename... Args>
    void add(
        std::format_string<Rendered<Args>...> fmt,
        Args&&... args
    ) { std::format_to(std::back_inserter(str), fmt, text::Extract(std::forward<Args>(args))...); }

    [[nodiscard]] auto render(bool use_colours) const -> std::string {
        return text::RenderColours(use_colours, str);
    }
};
